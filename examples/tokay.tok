# This is Tokay's own grammar expressed as a Tokay grammar
#
# This grammar was generated by the tokay_dump!()-macro from src/compiler/macros.rs,
# but some manual intervention was required, especially for the character-classes.
# It hopefully will serve as the source grammar in a future Tokay release.
#
# This parser can be executed by Tokay and parse itself with the call
#
#     tokay examples/tokay.tok -- examples/tokay.tok
#

_ : @{
    [\t ]+
    '#' [^\n]*
    '\\' '\n'
}

___ : @{
    peek not [A-Z_a-z] _
    EOF
}

T_EOL : @{
    '\n' _
    '\r' '\n'? _
    ';' _
    EOF
    peek '}'
}

T_OctDigit : @{
    [0-7]
}

T_HexDigit : @{
    [0-9A-Fa-f]
}

T_EscapeSequence : @{
    'a' "\x07"
    'b' "\x08"
    'f' "\x0c"
    'n' "\n"
    'r' "\r"
    't' "\t"
    'v' "\x0b"
    T_OctDigit T_OctDigit T_OctDigit
    'x' T_HexDigit T_HexDigit
    'u' T_HexDigit T_HexDigit T_HexDigit T_HexDigit
    'U' T_HexDigit T_HexDigit T_HexDigit T_HexDigit T_HexDigit T_HexDigit T_HexDigit T_HexDigit
    Any
}

T_Identifier : @{
    ast("identifier", Ident)
}

T_Consumable : @{
    [A-Z_] [0-9A-Z_a-z]*  ast("identifier", $0)
}

T_Alias : @{
    [A-Z_a-z] [0-9A-Z_a-z]*  ast("value_string", $0)
}

T_String : @{
    '"' {
        '\\' T_EscapeSequence
        [^\\\"]
        EOF  error("Unclosed string, expecting '\"'")
    }*  str_join("", $2) expect '"'
}

T_Touch : @{
    '\'' {
        '\\' T_EscapeSequence
        [^\\\']
        EOF  error("Unclosed match, expecting '\''")
    }*  str_join("", $2) expect '\''
}

T_Integer : @{
    ast("value_integer", Int)
}

T_Float : @{
    ast("value_float", Float)
}

CclChar : @{
    '\\' T_EscapeSequence
    [^\]]
    EOF  error("Unclosed character-class, expecting ']'")
}

CclRange : @{
    CclChar '-' CclChar  ast("range", ($1, $3))
    CclChar  ast("char")
}

Ccl : @{
    '^' CclRange*  ast("ccl_neg")
    CclRange*  ast("ccl")
}

Subscript : @{
    '[' _ Expression ']' _  ast("index")
}

Attribute : @{
    '.' _ T_Alias  ast("attribute")
}

Capture : @{
    '$' T_Alias _  ast("capture_alias")
    '$' T_Integer _  ast("capture_index")
    '$' '(' _ (T_EOL _)* Expression ')' _  ast("capture_expr")
    '$'  error("'$': Expecting identifier, integer or (expression)")
}

Variable : @{
    T_Identifier
    Capture
}

Lvalue : @{
    Variable _ {
        Subscript
    }*  ast("lvalue")
}

Load : @{
    Lvalue '++'  ast("inplace_post_inc")
    Lvalue '--'  ast("inplace_post_dec")
    '++' expect Lvalue  ast("inplace_pre_inc")
    '--' expect Lvalue  ast("inplace_pre_dec")
    Variable
}

CallParameter : @{
    T_Identifier _ '=' _ expect Expression  ast("param_named")
    Expression  ast("param")
}

CallParameters : @{
    (CallParameter (',' _)? (T_EOL _)*)+
}

Literal : @{
    'true' ___  ast("value_true")
    'false' ___  ast("value_false")
    'void' ___  ast("value_void")
    'null' ___  ast("value_null")
    T_String  ast("value_string")
    T_Float
    T_Integer
}

InlineSequenceItem : @{
    T_Alias _ '=>' _ expect Expression  ast("alias")
    Expression '=>' _ expect Expression  ast("alias")
    Expression
}

InlineSequence : @{
    # Special case: Expression followed by "," is considered as a list with a single item (syntactic sugar)
    Expression (T_EOL _)* (',' _)? (T_EOL _)* peek ')'  ast("list")

    # A sequence is a list of items optionally separated by ","
    (InlineSequenceItem (T_EOL _)* (',' _)? (T_EOL _)*)+  ast("sequence")

    # The empty sequences generates an empty list
    Void  ast("list")
}

InlineSequences : @{
    '(' _ (T_EOL _)* InlineSequence ((T_EOL _)* '|' _ (T_EOL _)* InlineSequence)+ (T_EOL _)* expect ')'  ast("block")
    '(' _ (T_EOL _)* InlineSequence (T_EOL _)* expect ')'
}

TokenLiteral : @{
    '\'' T_Touch '\''  ast("value_token_match")
    T_Touch  ast("value_token_touch")
    '.'  ast("value_token_any")
    '[' Ccl ']'  ast("value_token_ccl")
}

TokenCall : @{
    TokenLiteral
    T_Consumable '(' _ (T_EOL _)* CallParameters? (T_EOL _)* expect ')'  ast("call")
    T_Consumable  ast("call")
    Parselet
    InlineSequences
    Block
}

Token : @{
    TokenCall '+'  ast("op_mod_pos")
    TokenCall '*'  ast("op_mod_kle")
    TokenCall '?'  ast("op_mod_opt")
    TokenCall
    'peek' ___ expect Token  ast("op_mod_peek")
    'not' ___ expect Token  ast("op_mod_not")
    'expect' ___ expect Token  ast("op_mod_expect")
}

Atomic : @{
    '(' _ (T_EOL _)* Expression (T_EOL _)* ')'
    Literal
    Token
    'if' ___ Expression (T_EOL _)* expect Statement ((T_EOL _)* 'else' ___ (T_EOL _)* expect Statement)?  ast("op_if")
    'for' ___ StatementOrEmpty ';' _ StatementOrEmpty ';' _ StatementOrEmpty StatementOrEmpty  ast("op_for")
    'for' ___  error("'for': Expecting start; condition; iter; statement")
    'loop' ___ Expression _ Statement  ast("op_loop")
    'loop' ___ expect Statement  ast("op_loop")
    Load
}

Rvalue : @{
    Rvalue '(' _ (T_EOL _)* CallParameters? expect ')' _  ast("call")
    Rvalue {
        Attribute
        Subscript
    }*  ast("rvalue")
    Atomic
}

Unary : @{
    '-' not '-' _ Unary  ast("op_unary_neg")
    '!' _ Unary  ast("op_unary_not")
    Rvalue _
}

MulDiv : @{
    MulDiv '*' _ expect Unary  ast("op_binary_mul")
    MulDiv '/' _ expect Unary  ast("op_binary_div")
    Unary
}

AddSub : @{
    AddSub '+' not '+' _ expect MulDiv  ast("op_binary_add")
    AddSub '-' not '-' _ expect MulDiv  ast("op_binary_sub")
    MulDiv
}

Compare : @{
    Compare '==' _ expect AddSub  ast("op_compare_eq")
    Compare '!=' _ expect AddSub  ast("op_compare_neq")
    Compare '<=' _ expect AddSub  ast("op_compare_lteq")
    Compare '>=' _ expect AddSub  ast("op_compare_gteq")
    Compare '<' _ expect AddSub  ast("op_compare_lt")
    Compare '>' _ expect AddSub  ast("op_compare_gt")
    AddSub
}

LogicalAnd : @{
    LogicalAnd '&&' _ expect Compare  ast("op_logical_and")
    Compare
}

LogicalOr : @{
    LogicalOr '||' _ expect LogicalAnd  ast("op_logical_or")
    LogicalAnd
}

Expression : @{
    Lvalue _ '=' not {
        '>'
        '='
    } _ expect Expression  ast("assign_hold")
    Lvalue _ '+=' _ expect Expression  ast("assign_add_hold")
    Lvalue _ '-=' _ expect Expression  ast("assign_sub_hold")
    Lvalue _ '*=' _ expect Expression  ast("assign_mul_hold")
    Lvalue _ '/=' _ expect Expression  ast("assign_div_hold")
    LogicalOr
}

StatementOrEmpty : @{
    Statement
     ast("op_nop")
}

Statement : @{
    'accept' ___ Expression?  ast("op_accept")
    'break' ___ Expression?  ast("op_break")
    'continue' ___ Expression?  ast("op_continue")
    'exit' ___ Expression?  ast("op_exit")
    'next' ___  ast("op_next")
    'push' ___ Expression?  ast("op_push")
    'reject' ___  ast("op_reject")
    'repeat' ___ Expression?  ast("op_repeat")
    'return' ___ Expression?  ast("op_accept")
    Lvalue _ '=' not {
        '>'
        '='
    } _ expect Expression  ast("assign")
    Lvalue _ '+=' _ expect Expression  ast("assign_add")
    Lvalue _ '-=' _ expect Expression  ast("assign_sub")
    Lvalue _ '*=' _ expect Expression  ast("assign_mul")
    Lvalue _ '/=' _ expect Expression  ast("assign_div")
    Expression
}

Argument : @{
    T_Identifier _ ('=' _ Expression?)?  ast("arg")
}

Arguments : @{
    (Argument (',' _)?)+
}

Parselet : @{
    '@' _ Arguments? Block  ast("value_parselet")
    '@' _ Arguments? Token  ast("value_parselet")
}

Block : @{
    '{' _ (T_EOL _)* '}'  ast("value_void")
    '{' _ Instruction+ _ expect '}'  ast("block")
}

SequenceItem : @{
    T_Alias _ '=>' _ expect Expression  ast("alias")
    Expression '=>' _ expect Expression  ast("alias")
    Statement
}

Sequence : @{
    (SequenceItem (',' _)?)+  ast("sequence")
}

Sequences : @{
    Sequence ('|' _ Sequence)+  ast("block")
    Sequence
}

SequencesOrExpression : @{
    Expression peek {
        T_EOL
        EOF
    }
    Sequences
}

Instruction : @{
    'begin' ___ Sequence expect T_EOL  ast("begin")
    'end' ___ Sequence expect T_EOL  ast("end")
    T_Identifier _ ':' _ expect SequencesOrExpression   ast("constant")
    Sequences
    T_EOL
}

Tokay : @{
    Instruction+
    .  error("Parse error, unexpected token", true)
}

# Original invocation
# _ Tokay expect EOF  ast("main")

# fixme: The invocation is a little bit ugly currently.
ast_print(@{_ Tokay expect EOF  ast("main")}())  # fixme...
